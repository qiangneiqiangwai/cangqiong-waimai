✦ AOP（Aspect-Oriented Programming，面向切面编程） 是一种编程思想，它的核心目的是：在不修改原有业务代码的情况下，给程序动态地添加功能。

为了让你彻底理解，我们用一个“外卖餐厅”的生活化例子来类比。

  ---

1. 场景类比：外卖餐厅的“打包员”

想象一家繁忙的外卖餐厅，它的核心业务（Service）是“厨师做菜”。

传统的做法（没有 AOP）
每个厨师（Service 方法）在做完菜（执行完业务逻辑）后，都要自己去干这几件事：
1. 记录日志：拿个本子写上“我在 12:00 做了一份宫保鸡丁”。
2. 权限检查：检查一下点单的人是不是 VIP。
3. 公共字段填充（我们要做的功能）：给盒饭贴上“生产日期”和“厨师工号”。

问题：
* 厨师很烦：我只会炒菜，为什么要管贴标签和写日志？
* 效率低：每个厨师都要重复做这些动作。
* 难以维护：如果老板规定“所有日志都要换一种格式写”，你得通知所有厨师去改习惯。

AOP 的做法
餐厅请了一个专门的“打包员”（切面 Aspect）。
现在，厨师（Service）只管专心炒菜。菜炒好往出餐口一放，打包员（Aspect） 就会自动凑过来，完成剩下的工作：
* 统一记录日志。
* 统一检查权限。
* 统一给盒饭贴上时间和工号（公共字段填充）。

好处：
* 厨师代码极其干净，只包含炒菜逻辑。
* 打包员的逻辑也是统一管理的，要改规则只改打包员一个人就行。
* 这就是 AOP 的精髓：将与核心业务无关的通用功能（横切关注点）剥离出来，统一管理。

  ---

2. AOP 的专业术语（配合例子）

在 Java Spring 中，AOP 有几个必须要懂的概念，对应到我们的例子里：

1. 连接点 (Joinpoint)
    * 定义：程序执行过程中可以插入代码的“点”。
    * 例子：厨师做完菜的那一刻、把菜放进锅里的那一刻、甚至报错把锅烧糊的那一刻，都叫连接点。Spring AOP 中，连接点通常指的是方法的执行。

2. 切入点 (Pointcut)
    * 定义：用来定义“在哪些连接点上切入”。并不是所有方法都需要增强，我们需要规则来筛选。
    * 例子：老板规定：“只有做热菜（insert/update 方法）的时候才需要贴标签，做凉菜（select 方法）不需要”。这个筛选规则就是切入点。
    * 代码体现：@annotation(com.sky.annotation.AutoFill) —— 意思是“只有贴了 @AutoFill 标签的方法，我才拦截”。

3. 通知 (Advice)
    * 定义：切面具体要干的“活”。以及什么时候干（方法执行前？后？还是报错时？）。
    * 类型：
        * Before（前置通知）：在厨师炒菜之前检查有没有食材。
        * AfterReturning（后置通知）：在厨师炒完菜之后贴标签。
        * Around（环绕通知）：这是最强大的，它能包围整个过程。比如：记录厨师炒菜一共花了多少时间（炒菜前记一下，炒菜后记一下，相减）。
    * 我们这次用的是：@Before，在 Mapper 方法执行 SQL 之前，把公共字段填好。

4. 切面 (Aspect)
    * 定义：切入点 + 通知 = 切面。它是一个类，包含了规则（拦截谁）和逻辑（做什么）。
    * 例子：那个“打包员”本人。

5. 目标对象 (Target)
    * 定义：被代理的对象，也就是原本的业务类。
    * 例子：厨师。

  ---

3. AOP 在 Spring 中的底层原理（面试必问）

你可能会问：“为什么打包员能自动凑过来？Java 代码不是一行行顺序执行的吗？”

Spring AOP 的底层依靠的是 动态代理 (Dynamic Proxy)。

1. 启动时：Spring 容器启动时，会检查所有的 Bean。
2. 发现目标：如果发现某个 Bean（比如 EmployeeMapper）的方法符合切入点规则（贴了 @AutoFill）。
3. 偷天换日：Spring 不会直接给你原本的 EmployeeMapper 对象，而是生成一个代理对象 (Proxy) 给你。
    * 这个代理对象长得和 EmployeeMapper 一模一样（实现了相同的接口）。
4. 执行时：当你调用 insert() 方法时，其实调用的是代理对象的 insert()。
    * 代理对象内部逻辑是这样的：

1         public void insert(Employee e) {
2             // 1. 先执行切面逻辑（Advice）
3             autoFillAspect.autoFill(e); // 帮你自动填充字段
4
5             // 2. 再调用原本对象的逻辑
6             originalMapper.insert(e);
7         }

总结

* AOP 就是为了给代码“解耦”。
* 它通过预编译方式或运行期动态代理，实现程序功能的统一维护。
* 在我们的项目中，AOP 就像一个隐形的助手，在你执行数据库插入/更新操作之前，默默地帮你把 createTime、createUser 等字段填好了，让你在写业务代码时完全不用操心这些琐事。

  ---

  第一幕：准备阶段 (定义规则)

  在比赛开始前（代码编写阶段），我们先要把规则制定好。

    1. 枚举 (`OperationType`) —— 指令卡
        * 我们定义了两张卡片：一张写着 INSERT（新增），一张写着 UPDATE（修改）。
        * 作用：用来区分当前操作需要填充哪些字段（是填4个还是填2个）。

    2. 注解 (`@AutoFill`) —— 特殊标记
        * 这是一个自定义的标签。我们规定，这个标签里必须夹带一张“指令卡”（枚举值）。
        * 作用：我们需要手动把这个标签贴在 Mapper 接口的具体方法上，比如 insert(Employee e) 方法上贴一个 @AutoFill(value = OperationType.INSERT)。
        * 潜台词：“喂，AOP 助手，注意这个方法！它执行前需要你帮我处理一下数据，处理规则按 INSERT 来！”

  ---

  第二幕：触发阶段 (AOP 拦截)

  现在，程序启动了，用户在前端点了一个“新增员工”按钮。

    3. AOP切面 (`AutoFillAspect`) —— 隐形管家
        * Spring 容器启动时，这个管家就一直潜伏在内存里。它有一个雷达（Pointcut 切入点），专门扫描那些贴了 @AutoFill 标记的方法。
        * 拦截动作：当程序运行到 Mapper 层的 insert 方法时，还没等 SQL 真正执行，AOP 管家突然跳出来，按下了暂停键。
        * 它说：“慢着！这个方法贴了标记，我要先进行前置处理 (Before Advice)。”

  ---

  第三幕：执行阶段 (反射登场)

  这是最核心、最精密的一步。AOP 管家拦截下来后，手里拿到了方法的参数（比如一个 Employee 对象），但他面临一个问题：

    * 困难：AOP 管家是一个通用的类，它根本不知道你传给他的是 Employee 还是 Dish 还是 Category。它只知道这是一个 Object。
    * 解决：这时候，反射 (Reflection) 大显神威。

  具体的反射运作流程：

    1. 获取指令：
        * 管家先看了一眼方法上的注解，发现是 INSERT。心里有数了：“我要填4个字段”。

    2. 准备数据：
        * 管家看一下手表：“现在是 2023-10-27 12:00:00”（获取 LocalDateTime.now()）。
        * 管家查一下工牌：“操作人是 ID 1001”（从 BaseContext 获取当前用户 ID）。

    3. 动态探查 (反射的核心)：
        * 管家手里拿着这个陌生的对象（Employee），开始用反射机制“摸骨”：
            * “你的类里有没有一个叫 setCreateTime 的方法？” -> 答：有。
            * “有没有叫 setCreateUser 的方法？” -> 答：有。
            * “有没有叫 setUpdateTime 的方法？” -> 答：有。
            * “有没有叫 setUpdateUser 的方法？” -> 答：有。

    4. 强制执行 (反射的魔力)：
        * 管家不需要显式地写 employee.setCreateTime(...)，而是使用反射的 API（Method.invoke()）直接操控这个对象。
        * 它像操纵木偶一样，强行调用了对象内部的这些 setter 方法，把刚才准备好的时间及 ID 塞了进去。

  ---

  第四幕：放行 (回归正常)

    4. AOP 放行
        * 管家把字段都填好后，说：“好了，你的数据完整了，走吧。”
        * 程序恢复运行，真正的 Mapper 方法开始执行。

    5. SQL 执行
        * MyBatis 拿到这个已经被 AOP 修改过的 Employee 对象。
        * 生成 SQL 语句：INSERT INTO employee (name, create_time, ...) VALUES ('张三', '2023-10-27 12:00:00', ...)。
        * 此时，数据库里就完美地记录下了包含公共字段的完整数据。

  ---

  一图胜千言（全流程汇总）

    1. 程序员 -> 手动在 Mapper 方法上贴 注解 (`@AutoFill`) + 枚举 (`INSERT`)。
    2. 程序运行 -> 触发 Mapper 方法。
    3. AOP -> 看到注解，拦截方法调用。
    4. AOP -> 准备数据（当前时间、当前用户）。
    5. 反射 -> 拿到方法参数（实体对象），动态调用其 setter 方法赋值。
    6. AOP -> 放行。
    7. MyBatis -> 执行 SQL，数据入库。

  这就是这四大技术点在一次请求中完美的“全运作过程”。
*   这个 AutoFillAspect 类就像一个尽职尽责的流水线质检员：
1. 盯着流水线（Mapper方法）。
2. 看到贴了标签（@AutoFill）的产品来了，就拦下来。
3. 看看标签上写的是“新产品”（INSERT）还是“返修品”（UPDATE）。
4. 拿起印章（反射），啪啪啪把生产日期（时间）和质检员名字（ID）盖上去。
5. 放行，让产品继续往下走（入库）。